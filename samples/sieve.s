;
; File generated by cc65 v 2.17 - Git 19925800
;
	.fopt		compiler,"cc65 v 2.17 - Git 19925800"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.dbg		file, "sieve.c", 2876, 1554126600
	.dbg		file, "/opt/cc-6502/share/cc65/include/stdlib.h", 5748, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/stdio.h", 6189, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/stddef.h", 3057, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/stdarg.h", 2913, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/ctype.h", 8462, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/time.h", 5941, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/conio.h", 8941, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/target.h", 3126, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/cbm.h", 11354, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/c64.h", 6969, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/_vic2.h", 10835, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/_sid.h", 3626, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/_6526.h", 3962, 1554133537
	.dbg		file, "/opt/cc-6502/share/cc65/include/cbm_filetype.h", 4949, 1554133537
	.forceimport	__STARTUP__
	.dbg		sym, "printf", "00", extern, "_printf"
	.dbg		sym, "toupper", "00", extern, "_toupper"
	.dbg		sym, "clock", "00", extern, "_clock"
	.dbg		sym, "kbhit", "00", extern, "_kbhit"
	.dbg		sym, "cgetc", "00", extern, "_cgetc"
	.import		_printf
	.import		_toupper
	.import		_clock
	.import		_kbhit
	.import		_cgetc
	.export		_main

.segment	"RODATA"

L0013:
	.byte	$D3,$49,$45,$56,$45,$20,$42,$45,$4E,$43,$48,$4D,$41,$52,$4B,$20
	.byte	$2D,$20,$43,$41,$4C,$43,$55,$4C,$41,$54,$49,$4E,$47,$20,$50,$52
	.byte	$49,$4D,$45,$53,$0D,$00
L0063:
	.byte	$D1,$20,$54,$4F,$20,$51,$55,$49,$54,$2C,$20,$41,$4E,$59,$20,$4F
	.byte	$54,$48,$45,$52,$20,$4B,$45,$59,$20,$43,$4F,$4E,$54,$49,$4E,$55
	.byte	$45,$53,$0D,$00
L0048:
	.byte	$D1,$20,$54,$4F,$20,$51,$55,$49,$54,$2C,$20,$41,$4E,$59,$20,$4F
	.byte	$54,$48,$45,$52,$20,$4B,$45,$59,$20,$46,$4F,$52,$20,$4C,$49,$53
	.byte	$54,$0D,$00
L0043:
	.byte	$D4,$49,$4D,$45,$20,$55,$53,$45,$44,$3A,$20,$25,$55,$2E,$25,$30
	.byte	$33,$55,$20,$53,$45,$43,$4F,$4E,$44,$53,$0D,$00
L001A:
	.byte	$D0,$4C,$45,$41,$53,$45,$20,$57,$41,$49,$54,$20,$50,$41,$54,$49
	.byte	$45,$4E,$54,$4C,$59,$20,$2E,$2E,$2E,$0D,$00
L0016:
	.byte	$42,$45,$54,$57,$45,$45,$4E,$20,$32,$20,$41,$4E,$44,$20,$25,$55
	.byte	$0D,$00
L005B:
	.byte	$25,$34,$44,$0D,$00

.segment	"BSS"

_Sieve:
	.res	16384,$00

; ---------------------------------------------------------------
; unsigned char __near__ ReadUpperKey (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ReadUpperKey: near

	.dbg	func, "ReadUpperKey", "00", static, "_ReadUpperKey"

.segment	"CODE"

;
; return toupper (cgetc ());
;
	.dbg	line, "sieve.c", 48
	jsr     _cgetc
	ldx     #$00
	jsr     _toupper
	ldx     #$00
;
; }
;
	.dbg	line, "sieve.c", 49
	rts
	.dbg	line

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

	.dbg	func, "main", "00", extern, "_main"
	.dbg	sym, "S", "00", register, "regbank", 4
	.dbg	sym, "I", "00", register, "regbank", 2
	.dbg	sym, "J", "00", register, "regbank", 0

.segment	"BSS"

L000F:
	.res	4,$00
L0010:
	.res	2,$00
L0011:
	.res	2,$00

.segment	"CODE"

;
; register unsigned char* S;
;
	.dbg	line, "sieve.c", 61
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; register unsigned       I;
;
	.dbg	line, "sieve.c", 62
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
;
; register unsigned       J;
;
	.dbg	line, "sieve.c", 63
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
;
; printf ("Sieve benchmark - calculating primes\n");
;
	.dbg	line, "sieve.c", 66
	lda     #<(L0013)
	ldx     #>(L0013)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; printf ("between 2 and %u\n", COUNT);
;
	.dbg	line, "sieve.c", 67
	lda     #<(L0016)
	ldx     #>(L0016)
	jsr     pushax
	ldx     #$40
	lda     #$00
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; printf ("Please wait patiently ...\n");
;
	.dbg	line, "sieve.c", 68
	lda     #<(L001A)
	ldx     #>(L001A)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; Ticks = clock();
;
	.dbg	line, "sieve.c", 71
	jsr     _clock
	sta     L000F
	stx     L000F+1
	ldy     sreg
	sty     L000F+2
	ldy     sreg+1
	sty     L000F+3
;
; I = 2;
;
	.dbg	line, "sieve.c", 74
	ldx     #$00
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
	jmp     L0022
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 76
L0020:	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L002E
;
; J = I*2;
;
	.dbg	line, "sieve.c", 78
	lda     regbank+2
	asl     a
	sta     regbank+0
	lda     regbank+2+1
	rol     a
	sta     regbank+0+1
;
; S = &Sieve[J];
;
	.dbg	line, "sieve.c", 79
	lda     #<(_Sieve)
	clc
	adc     regbank+0
	sta     regbank+4
	lda     #>(_Sieve)
	adc     regbank+0+1
	sta     regbank+4+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
	jmp     L002F
;
; *S = 1;
;
	.dbg	line, "sieve.c", 81
L002D:	lda     #$01
	ldy     #$00
	sta     (regbank+4),y
;
; S += I;
;
	.dbg	line, "sieve.c", 82
	lda     regbank+2
	clc
	adc     regbank+4
	sta     regbank+4
	lda     regbank+2+1
	adc     regbank+4+1
	sta     regbank+4+1
;
; J += I;
;
	.dbg	line, "sieve.c", 83
	lda     regbank+2
	clc
	adc     regbank+0
	sta     regbank+0
	lda     regbank+2+1
	adc     regbank+0+1
	sta     regbank+0+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
L002F:	ldx     regbank+0+1
	cpx     #$40
	bcc     L002D
;
; ++I;
;
	.dbg	line, "sieve.c", 86
L002E:	inc     regbank+2
	bne     L0022
	inc     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
L0022:	lda     regbank+2+1
	cmp     #$00
	bne     L0024
	lda     regbank+2
	cmp     #$80
L0024:	bcc     L0020
;
; Ticks = clock() - Ticks;
;
	.dbg	line, "sieve.c", 90
	jsr     _clock
	jsr     pusheax
	lda     L000F+3
	sta     sreg+1
	lda     L000F+2
	sta     sreg
	ldx     L000F+1
	lda     L000F
	jsr     tossubeax
	sta     L000F
	stx     L000F+1
	ldy     sreg
	sty     L000F+2
	ldy     sreg+1
	sty     L000F+3
;
; Sec = (unsigned) (Ticks / CLOCKS_PER_SEC);
;
	.dbg	line, "sieve.c", 91
	lda     L000F+3
	sta     sreg+1
	lda     L000F+2
	sta     sreg
	ldx     L000F+1
	lda     L000F
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     L0010
	stx     L0010+1
;
; Milli = ((Ticks % CLOCKS_PER_SEC) * 1000) / CLOCKS_PER_SEC;
;
	.dbg	line, "sieve.c", 92
	lda     L000F+3
	sta     sreg+1
	lda     L000F+2
	sta     sreg
	ldx     L000F+1
	lda     L000F
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosumod0ax
	jsr     pusheax
	ldx     #$03
	lda     #$E8
	jsr     tosumul0ax
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     L0011
	stx     L0011+1
;
; printf ("Time used: %u.%03u seconds\n", Sec, Milli);
;
	.dbg	line, "sieve.c", 95
	lda     #<(L0043)
	ldx     #>(L0043)
	jsr     pushax
	lda     L0010
	ldx     L0010+1
	jsr     pushax
	lda     L0011
	ldx     L0011+1
	jsr     pushax
	ldy     #$06
	jsr     _printf
;
; printf ("Q to quit, any other key for list\n");
;
	.dbg	line, "sieve.c", 96
	lda     #<(L0048)
	ldx     #>(L0048)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () != 'Q') {
;
	.dbg	line, "sieve.c", 99
	jsr     _ReadUpperKey
	cmp     #$D1
	beq     L004F
;
; J = 0;
;
	.dbg	line, "sieve.c", 101
	ldx     #$00
	txa
	sta     regbank+0
	sta     regbank+0+1
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
L004E:	ldx     regbank+2+1
	cpx     #$40
	bcs     L004F
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 103
	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L005E
;
; printf ("%4d\n", I);
;
	.dbg	line, "sieve.c", 104
	lda     #<(L005B)
	ldx     #>(L005B)
	jsr     pushax
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; if (++J == 23) {
;
	.dbg	line, "sieve.c", 105
	inc     regbank+0
	bne     L0060
	inc     regbank+0+1
L0060:	lda     regbank+0+1
	bne     L005E
	lda     regbank+0
	cmp     #$17
	bne     L005E
;
; printf ("Q to quit, any other key continues\n");
;
	.dbg	line, "sieve.c", 106
	lda     #<(L0063)
	ldx     #>(L0063)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 107
	jsr     _ReadUpperKey
	cmp     #$D1
;
; break;
;
	.dbg	line, "sieve.c", 108
	beq     L004F
;
; J = 0;
;
	.dbg	line, "sieve.c", 110
	lda     #$00
	sta     regbank+0
	sta     regbank+0+1
;
; if (kbhit() && ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 113
L005E:	jsr     _kbhit
	tax
	beq     L0050
	jsr     _ReadUpperKey
	cmp     #$D1
	beq     L004F
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
L0050:	inc     regbank+2
	bne     L004E
	inc     regbank+2+1
	jmp     L004E
;
; return EXIT_SUCCESS;
;
	.dbg	line, "sieve.c", 119
L004F:	ldx     #$00
	txa
;
; }
;
	.dbg	line, "sieve.c", 120
	pha
	tay
L006E:	lda     (sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L006E
	pla
	jmp     incsp6
	.dbg	line

.endproc

